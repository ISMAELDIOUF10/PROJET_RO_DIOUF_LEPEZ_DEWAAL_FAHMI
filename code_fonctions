import sys
import os

class TransportProblem:
    def __init__(self, filepath):
        self.filename = filepath
        self.n = 0
        self.m = 0
        self.costs = []
        self.supply = []
        self.demand = []
        self.transport = []
        # Variables potentiels
        self.u = []
        self.v = []
        self.marginals = []
        
        self.load_data()

    def load_data(self):
        """Lecture des données robuste."""
        try:
            with open(self.filename, 'r') as f:
                content = f.read().split()
            
            iterator = iter(content)
            try:
                self.n = int(next(iterator))
                self.m = int(next(iterator))
                
                self.costs = [[0] * self.m for _ in range(self.n)]
                self.supply = [0] * self.n
                self.demand = [0] * self.m

                # Lecture Coûts et Provisions
                for i in range(self.n):
                    for j in range(self.m):
                        self.costs[i][j] = float(next(iterator))
                    self.supply[i] = float(next(iterator))
                
                # Lecture Commandes
                for j in range(self.m):
                    self.demand[j] = float(next(iterator))
                    
                self.transport = [[0] * self.m for _ in range(self.n)]
                
            except StopIteration:
                print(f"Erreur : Le fichier {self.filename} est incomplet.")
        except FileNotFoundError:
            print(f"Erreur : Le fichier {self.filename} est introuvable.")

    # --- AFFICHAGE ---
    def _print_separator(self, col_widths):
        print("    +" + "+".join(["-" * (w + 2) for w in col_widths]) + "+")

    def display_matrix(self, matrix, title="TABLEAU", show_supply_demand=False):
        print(f"\n=== {title} ===")
        if not matrix or not matrix[0]: return

        col_widths = []
        for j in range(self.m):
            max_w = len(f"C{j+1}")
            for i in range(self.n):
                val = matrix[i][j]
                val_str = f"{val:g}" if val is not None else "."
                max_w = max(max_w, len(val_str))
            if show_supply_demand:
                max_w = max(max_w, len(f"{self.demand[j]:g}"))
            col_widths.append(max_w)
            
        supply_width = 0
        if show_supply_demand:
            supply_width = max(len("Prov."), max(len(f"{s:g}") for s in self.supply))

        # En-têtes
        header_str = "    |"
        for j, w in enumerate(col_widths):
            header_str += f" {f'C{j+1}':^{w}} |"
        if show_supply_demand:
            header_str += f" {'Prov.':^{supply_width}} |"
        
        print("-" * len(header_str))
        print(header_str)
        self._print_separator(col_widths + ([supply_width] if show_supply_demand else []))

        # Contenu
        for i in range(self.n):
            row_str = f" P{i+1:<2}|"
            for j in range(self.m):
                val = matrix[i][j]
                val_str = f"{val:g}" if val is not None else "."
                row_str += f" {val_str:^{col_widths[j]}} |"
            
            if show_supply_demand:
                row_str += f" {self.supply[i]:^{supply_width}g} |"
            print(row_str)
        
        self._print_separator(col_widths + ([supply_width] if show_supply_demand else []))

        # Demandes
        if show_supply_demand:
            dem_str = " Com|"
            for j in range(self.m):
                dem_str += f" {self.demand[j]:^{col_widths[j]}g} |"
            print(dem_str)
            print("-" * len(header_str))

    def display_potentials(self):
        print("\n=== POTENTIELS ===")
        u_str = ", ".join([f"U{i+1}={val:g}" if val is not None else f"U{i+1}=?" for i, val in enumerate(self.u)])
        v_str = ", ".join([f"V{j+1}={val:g}" if val is not None else f"V{j+1}=?" for j, val in enumerate(self.v)])
        print(f"Lignes (U) : {u_str}")
        print(f"Colonnes (V) : {v_str}")

    # --- ALGORITHMES ---
    def solve_north_west(self):
        """Algorithme Nord-Ouest"""
        self.transport = [[0] * self.m for _ in range(self.n)]
        rem_supply = self.supply[:]
        rem_demand = self.demand[:]
        
        i, j = 0, 0
        while i < self.n and j < self.m:
            qty = min(rem_supply[i], rem_demand[j])
            self.transport[i][j] = qty
            rem_supply[i] -= qty
            rem_demand[j] -= qty
            
            if rem_supply[i] == 0 and i < self.n - 1:
                i += 1
            elif rem_demand[j] == 0 and j < self.m - 1:
                j += 1
            else:
                i += 1
                j += 1

    def solve_balas_hammer(self):
        """Algorithme Balas-Hammer"""
        self.transport = [[0] * self.m for _ in range(self.n)]
        rem_supply = self.supply[:]
        rem_demand = self.demand[:]
        rows_done = [False] * self.n
        cols_done = [False] * self.m
        
        # Sécurité boucle
        ops = 0
        max_ops = self.n * self.m * 2 

        while ops < max_ops:
            if all(rows_done) or all(cols_done): break

            penalties = []
            
            # Pénalités Lignes
            for i in range(self.n):
                if not rows_done[i]:
                    valid_costs = [self.costs[i][j] for j in range(self.m) if not cols_done[j]]
                    if len(valid_costs) >= 2:
                        s = sorted(valid_costs)
                        pen = s[1] - s[0]
                    elif len(valid_costs) == 1:
                        pen = valid_costs[0]
                    else:
                        pen = 0
                    penalties.append(('row', i, pen))
            
            # Pénalités Colonnes
            for j in range(self.m):
                if not cols_done[j]:
                    valid_costs = [self.costs[i][j] for i in range(self.n) if not rows_done[i]]
                    if len(valid_costs) >= 2:
                        s = sorted(valid_costs)
                        pen = s[1] - s[0]
                    elif len(valid_costs) == 1:
                        pen = valid_costs[0]
                    else:
                        pen = 0
                    penalties.append(('col', j, pen))

            if not penalties: break

            # Choix max pénalité
            penalties.sort(key=lambda x: x[2], reverse=True)
            best_type, idx, _ = penalties[0]
            
            target_i, target_j = -1, -1
            
            if best_type == 'row':
                target_i = idx
                min_c = float('inf')
                for j in range(self.m):
                    if not cols_done[j] and self.costs[target_i][j] < min_c:
                        min_c = self.costs[target_i][j]
                        target_j = j
            else:
                target_j = idx
                min_c = float('inf')
                for i in range(self.n):
                    if not rows_done[i] and self.costs[i][target_j] < min_c:
                        min_c = self.costs[i][target_j]
                        target_i = i
            
            qty = min(rem_supply[target_i], rem_demand[target_j])
            self.transport[target_i][target_j] = qty
            rem_supply[target_i] -= qty
            rem_demand[target_j] -= qty
            
            if rem_supply[target_i] == 0:
                rows_done[target_i] = True
            else:
                cols_done[target_j] = True
            ops += 1

    def get_total_cost(self):
        return sum(self.transport[i][j] * self.costs[i][j] for i in range(self.n) for j in range(self.m))

    # --- MARCHE-PIED ---
    def check_connectivity_bfs(self):
        edges = []
        nodes = set()
        for i in range(self.n):
            for j in range(self.m):
                if self.transport[i][j] > 0:
                    edges.append((i, self.n + j))
                    nodes.add(i)
                    nodes.add(self.n + j)
        
        if not nodes: return False
        start = list(nodes)[0]
        visited = {start}
        queue = [start]
        
        while queue:
            curr = queue.pop(0)
            for u, v in edges:
                if u == curr and v not in visited:
                    visited.add(v); queue.append(v)
                elif v == curr and u not in visited:
                    visited.add(u); queue.append(u)
        
        return len(visited) == (self.n + self.m)

    def calculate_potentials(self):
        self.u = [None] * self.n
        self.v = [None] * self.m
        self.u[0] = 0
        changed = True
        while changed:
            changed = False
            for i in range(self.n):
                for j in range(self.m):
                    if self.transport[i][j] > 0:
                        if self.u[i] is not None and self.v[j] is None:
                            self.v[j] = self.costs[i][j] - self.u[i]
                            changed = True
                        elif self.v[j] is not None and self.u[i] is None:
                            self.u[i] = self.costs[i][j] - self.v[j]
                            changed = True

    def calculate_marginals(self):
        self.marginals = [[None] * self.m for _ in range(self.n)]
        for i in range(self.n):
            for j in range(self.m):
                if self.transport[i][j] == 0:
                    if self.u[i] is not None and self.v[j] is not None:
                        self.marginals[i][j] = self.costs[i][j] - self.u[i] - self.v[j]
                    else:
                        self.marginals[i][j] = 0

    def get_cycle_bfs(self, start_i, start_j):
        """Cherche un cycle commençant en start_i, start_j"""
        queue = []
        # Horizontal
        for j in range(self.m):
            if j != start_j and self.transport[start_i][j] > 0:
                queue.append((start_i, j, [(start_i, start_j), (start_i, j)], 'row'))
        # Vertical
        for i in range(self.n):
            if i != start_i and self.transport[i][start_j] > 0:
                queue.append((i, start_j, [(start_i, start_j), (i, start_j)], 'col'))

        while queue:
            curr_r, curr_c, path, direction = queue.pop(0)
            
            # Retour au départ
            if curr_r == start_i and curr_c == start_j and len(path) > 3:
                return path[:-1]

            if direction == 'row': # Doit aller vertical
                for i in range(self.n):
                    if i != curr_r:
                        if self.transport[i][curr_c] > 0 or (i == start_i and curr_c == start_j):
                            if (i, curr_c) != path[-2]:
                                queue.append((i, curr_c, path + [(i, curr_c)], 'col'))
            
            elif direction == 'col': # Doit aller horizontal
                for j in range(self.m):
                    if j != curr_c:
                        if self.transport[curr_r][j] > 0 or (curr_r == start_i and j == start_j):
                            if (curr_r, j) != path[-2]:
                                queue.append((curr_r, j, path + [(curr_r, j)], 'row'))
        return None

    def update_transport_on_cycle(self, cycle):
        """Met à jour le transport sur le cycle"""
        theta = float('inf')
        
        # Trouver theta (min des cases négatives - indices impairs)
        for k in range(1, len(cycle), 2):
            i, j = cycle[k]
            if self.transport[i][j] < theta:
                theta = self.transport[i][j]
        
        print(f"  -> Quantité déplacée (Theta) : {theta}")

        # Appliquer
        for k, (i, j) in enumerate(cycle):
            if k % 2 == 0:
                self.transport[i][j] += theta
            else:
                self.transport[i][j] -= theta
        return theta
